import 'package:crypto_keys/crypto_keys.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:hex/hex.dart';
import 'package:webauthn/src/util/webauthn_cryptography.dart';

import '../helpers.dart';

// Create key
//    openssl ecparam -name prime256v1 -genkey -noout -out private-key.pem
// Create pub key
//    openssl ec -in private-key.pem -pubout -out public-key.pem
// Get public key data
//    openssl ec -pubin -in public-key.pem -text -noout
// Get private key data
//    openssl ec -in private-key.pem -text -noout
// Sign data
//    echo -n 'this is a test' | openssl dgst -sha256 -sign private-key.pem > sig.bin
// Verify sig
//    echo -n 'this is a test' | openssl dgst -sha256 -verify public-key.pem -signature sig.bin
// Convert sig_test to data:
//    openssl asn1parse -inform DER -in sig.bin
// Bytes to hex:
//    xxd -p -c 256 <bytes>
// Hex to bytes:
//    xxd -r -p <hex>

/* Below is the key information as generated by OpenSSL using our curves, etc. */
const pkEcc =
    '138ffcaff901f9bce953370f0f66e3aff2d4ba0c5f75bac4102b67643c276bea';
const pubX = 'a3f8891006e42595a86b87217414d4cf126859e0e01038c6a9fae06adf67c083';
const pubY = 'a684844334e03572f45ef91073e3d9d3cb16da16150d6f4cc4f00db78a5b6812';
const testSignatureCryptoKeys =
    '99330616aa7580a90320e4d486b87aea7125f1c2ea014a3e201ff5a8ce1c414712c7c89f11d8c915fba046e3026decbed1f298c7167e75112be4febed590eb37';
// r: 99330616aa7580a90320e4d486b87aea7125f1c2ea014a3e201ff5a8ce1c4147
// s: 12c7c89f11d8c915fba046e3026decbed1f298c7167e75112be4febed590eb37
const testSignatureOpenSSL =
    '304502210099330616aa7580a90320e4d486b87aea7125f1c2ea014a3e201ff5a8ce1c4147022012c7c89f11d8c915fba046e3026decbed1f298c7167e75112be4febed590eb37';
const testSignatureDER =
    '3044022099330616aa7580a90320e4d486b87aea7125f1c2ea014a3e201ff5a8ce1c4147022012c7c89f11d8c915fba046e3026decbed1f298c7167e75112be4febed590eb37';

const testString = 'this is a test';

final pkKey = EcPrivateKey(
  curve: curves.p256,
  eccPrivateKey: BigInt.parse(pkEcc, radix: 16),
);
final pubKey = EcPublicKey(
  curve: curves.p256,
  xCoordinate: BigInt.parse(pubX, radix: 16),
  yCoordinate: BigInt.parse(pubY, radix: 16),
);
final signatureCryptoKeys = ui(HEX.decode(testSignatureCryptoKeys));
final signatureOpenSSL = ui(HEX.decode(testSignatureOpenSSL));
final signatureDER = ui(HEX.decode(testSignatureDER));

void main() {
  const sut = WebauthnCryptography();

  group('verification', () {
    test('verifies external signature correctly', () {
      // Verify the signature collected from openssl is correct
      final result = sut.verifySignature(
          pubKey, ui(testString.codeUnits), signatureOpenSSL);
      expect(result, isTrue);
    });
  });

  group('signing', () {
    test('signs value correctly', () {
      // Sign using private key from openssl
      final result = sut.performSignature(
        ui(testString.codeUnits),
        privateKey: pkKey,
      );

      // Signature looks right
      expect(result.length, inInclusiveRange(70, 72),
          reason: 'Signature len should be between 70 and 72');

      // Verify using public key from openssl
      final verifiedItself =
          sut.verifySignature(pubKey, ui(testString.codeUnits), result);
      expect(verifiedItself, isTrue);
    });
  });

  group('transformations', () {
    test('transforms an openssl signature to a crypto_keys signature', () {
      final localKey = WebauthnCryptography.DERToSignature(signatureOpenSSL);
      expect(localKey, equals(signatureCryptoKeys));
    });

    test(
      'transforms an invalid DER signature to a crypto_keys signature',
      () {
        final localKey = WebauthnCryptography.DERToSignature(signatureDER);
        expect(localKey, equals(signatureCryptoKeys));
      },
    );

    test(
      'transforms a crypto_keys signature to a DER signature',
      () {
        final remoteKey =
            WebauthnCryptography.signatureToDER(signatureCryptoKeys);
        expect(remoteKey, equals(signatureOpenSSL));
      },
    );
  });

  group('hashing', () {
    test('sha256', () {
      final bits = WebauthnCryptography.sha256("testing");
      final encoded = HEX.encode(bits.toList());
      expect(
          encoded,
          equals(
              'cf80cd8aed482d5d1527d7dc72fceff84e6326592848447d2dc0b0e87dfc9a90'));
    });
  });
}
